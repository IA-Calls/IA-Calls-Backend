const XLSX = require('xlsx');
const fs = require('fs');
const path = require('path');

class FileProcessor {
  /**
   * Procesa un archivo en base64 y extrae informaci√≥n de clientes
   * @param {string} base64Data - Archivo en formato base64
   * @param {string} documentName - Nombre del documento original
   * @returns {Object} - Objeto con datos extra√≠dos y archivo generado
   */
  static async processFile(base64Data, documentName) {
    try {
      console.log(`üìÅ Iniciando procesamiento de archivo: ${documentName}`);
      
      // Decodificar base64
      const buffer = Buffer.from(base64Data, 'base64');
      const fileSizeMB = buffer.length / 1024 / 1024;
      console.log(`üìä Tama√±o del archivo: ${fileSizeMB.toFixed(2)} MB`);
      
      // Validar tama√±o del archivo (m√°ximo 50MB)
      if (fileSizeMB > 50) {
        throw new Error(`El archivo es demasiado grande (${fileSizeMB.toFixed(2)} MB). El tama√±o m√°ximo permitido es 50 MB.`);
      }
      
      // Validar que el archivo no est√© vac√≠o
      if (buffer.length === 0) {
        throw new Error('El archivo est√° vac√≠o o corrupto.');
      }
      
      // Leer el archivo Excel
      const workbook = XLSX.read(buffer, { type: 'buffer' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // Convertir a JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      console.log(`üìã Total de filas en el archivo: ${jsonData.length}`);
      
      // Validar que el archivo tenga datos
      if (jsonData.length < 2) {
        throw new Error('El archivo Excel debe tener al menos una fila de encabezados y una fila de datos.');
      }
      
      // Validar n√∫mero m√°ximo de filas (m√°ximo 100,000 filas)
      if (jsonData.length > 100000) {
        throw new Error(`El archivo tiene demasiadas filas (${jsonData.length}). El m√°ximo permitido es 100,000 filas.`);
      }
      
      // Extraer encabezados (primera fila)
      const headers = jsonData[0] || [];
      
      // Encontrar √≠ndices de columnas importantes
      const nameIndex = this.findColumnIndex(headers, ['nombre', 'name', 'nombres', 'cliente']);
      const phoneIndex = this.findColumnIndex(headers, ['telefono', 'phone', 'celular', 'movil', 'tel']);
      const emailIndex = this.findColumnIndex(headers, ['email', 'correo', 'e-mail']);
      const addressIndex = this.findColumnIndex(headers, ['direccion', 'address', 'domicilio']);
      
      if (nameIndex === -1 || phoneIndex === -1) {
        throw new Error('No se encontraron las columnas requeridas: nombre y tel√©fono');
      }
      
      // Procesar datos (excluyendo la fila de encabezados)
      const clientsData = [];
      const totalRows = jsonData.length - 1; // Excluir encabezados
      let processedRows = 0;
      let validClients = 0;
      
      console.log(`üîÑ Procesando ${totalRows} filas de datos...`);
      
      for (let i = 1; i < jsonData.length; i++) {
        const row = jsonData[i];
        processedRows++;
        
        // Log de progreso cada 100 filas
        if (processedRows % 100 === 0) {
          console.log(`üìà Progreso: ${processedRows}/${totalRows} filas procesadas (${validClients} clientes v√°lidos)`);
        }
        
        if (row && row.length > 0) {
          const clientData = {
            name: this.cleanValue(row[nameIndex]),
            phone: this.cleanPhone(row[phoneIndex]),
            email: emailIndex !== -1 ? this.cleanValue(row[emailIndex]) : null,
            address: addressIndex !== -1 ? this.cleanValue(row[addressIndex]) : null,
            category: 'imported',
            status: 'pending',
            metadata: {
              source: documentName,
              importDate: new Date().toISOString(),
              originalRow: row
            }
          };
          
          // Solo agregar si tiene nombre y tel√©fono v√°lidos
          if (clientData.name && clientData.phone) {
            clientsData.push(clientData);
            validClients++;
          }
        }
      }
      
      console.log(`‚úÖ Procesamiento completado: ${validClients} clientes v√°lidos de ${totalRows} filas`);
      
      // Generar archivo Excel con los datos procesados
      console.log(`üìÑ Generando archivo Excel procesado...`);
      const processedWorkbook = XLSX.utils.book_new();
      const processedWorksheet = XLSX.utils.json_to_sheet(clientsData);
      XLSX.utils.book_append_sheet(processedWorkbook, processedWorksheet, 'Clientes Procesados');
      
      // Generar nombre √∫nico para el archivo
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const fileName = `clientes_procesados_${timestamp}.xlsx`;
      
      // Generar buffer del archivo Excel
      const excelBuffer = XLSX.write(processedWorkbook, { type: 'buffer', bookType: 'xlsx' });
      console.log(`üìä Archivo Excel generado: ${(excelBuffer.length / 1024 / 1024).toFixed(2)} MB`);
      
      // Convertir a base64 para subir a GCP
      const processedBase64Data = excelBuffer.toString('base64');
      
      // Subir a GCP usando la funci√≥n de helpers
      console.log(`‚òÅÔ∏è Subiendo archivo a Google Cloud Storage...`);
      const { uploadDocumentToGCP } = require('../utils/helpers');
      const uploadResult = await uploadDocumentToGCP(processedBase64Data, fileName, {
        documentType: 'processed_excel',
        source: 'file_processor',
        totalClients: clientsData.length,
        originalDocument: documentName
      });
      
      console.log(`‚úÖ Archivo subido exitosamente a GCP: ${uploadResult.fileName}`);
      
      return {
        success: true,
        clientsData,
        processedFile: {
          fileName: uploadResult.fileName,
          gcsUrl: uploadResult.publicUrl,
          downloadUrl: uploadResult.downloadUrl,
          totalClients: clientsData.length,
          uploadedAt: uploadResult.uploadedAt
        }
      };
      
    } catch (error) {
      console.error('‚ùå Error procesando archivo:', error);
      
      // Manejo espec√≠fico de errores para archivos grandes
      if (error.message.includes('Cannot access') || error.message.includes('before initialization')) {
        console.error('üîß Error de inicializaci√≥n de variables detectado');
        throw new Error('Error interno del procesador de archivos. Por favor, intente nuevamente.');
      }
      
      if (error.message.includes('memory') || error.message.includes('heap')) {
        console.error('üíæ Error de memoria detectado - archivo muy grande');
        throw new Error('El archivo es demasiado grande para procesar. Intente con un archivo m√°s peque√±o o divida el archivo en partes.');
      }
      
      if (error.message.includes('timeout')) {
        console.error('‚è∞ Error de timeout detectado');
        throw new Error('El procesamiento del archivo tard√≥ demasiado tiempo. Intente con un archivo m√°s peque√±o.');
      }
      
      throw new Error(`Error procesando archivo: ${error.message}`);
    }
  }
  
  /**
   * Encuentra el √≠ndice de una columna basado en posibles nombres
   * @param {Array} headers - Array de encabezados
   * @param {Array} possibleNames - Posibles nombres de la columna
   * @returns {number} - √çndice de la columna o -1 si no se encuentra
   */
  static findColumnIndex(headers, possibleNames) {
    for (let i = 0; i < headers.length; i++) {
      const header = String(headers[i]).toLowerCase().trim();
      if (possibleNames.some(name => header.includes(name.toLowerCase()))) {
        return i;
      }
    }
    return -1;
  }
  
  /**
   * Limpia y valida un valor
   * @param {*} value - Valor a limpiar
   * @returns {string|null} - Valor limpio o null si est√° vac√≠o
   */
  static cleanValue(value) {
    if (!value) return null;
    const cleaned = String(value).trim();
    return cleaned.length > 0 ? cleaned : null;
  }
  
  /**
   * Limpia y formatea un n√∫mero de tel√©fono
   * @param {*} phone - N√∫mero de tel√©fono a limpiar
   * @returns {string|null} - Tel√©fono limpio o null si no es v√°lido
   */
  static cleanPhone(phone) {
    if (!phone) return null;
    
    let cleaned = String(phone).replace(/\D/g, ''); // Solo n√∫meros
    
    // Si empieza con 0, removerlo
    if (cleaned.startsWith('0')) {
      cleaned = cleaned.substring(1);
    }
    
    // Si empieza con 57 (c√≥digo de Colombia), removerlo
    if (cleaned.startsWith('57')) {
      cleaned = cleaned.substring(2);
    }
    
    // Validar que tenga al menos 7 d√≠gitos
    if (cleaned.length < 7) {
      return null;
    }
    
    return cleaned;
  }
}

module.exports = FileProcessor;
